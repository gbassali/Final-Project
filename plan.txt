Phase 1 – Core CRUD for main entities

You need simple functions for Member, Trainer, AdminStaff, Room, FitnessClass. These are the building blocks for all higher-level features.

1. Member basic services

Models (models/memberModel.ts)

 createMember(data)

 getMemberById(id)

 updateMember(id, data)

 listMembers()

Services (app/memberService.ts)

 registerMember(input) → calls createMember

 updateMemberProfile(memberId, changes) → calls updateMember

(We’ll hook health history & dashboard later.)

2. Trainer basic services

models/trainerModel.ts

 createTrainer(data)

 getTrainerById(id)

 listTrainers()

3. AdminStaff

models/adminModel.ts

 createAdminStaff(data)

 getAdminById(id)

(You may not call this a lot, but it makes the entity “real” in the DB.)

4. Rooms

models/roomModel.ts

 createRoom(data)

 listRooms()

 getRoomById(id)

(Admin will use these for room booking.)

5. FitnessClass (scheduled group classes)

models/fitnessClassModel.ts

 createFitnessClass(data)

 getFitnessClassById(id)

 listUpcomingFitnessClasses(range?)

 updateFitnessClass(id, data)

 cancelFitnessClass(id) (e.g., set some “cancelled” state or just delete if allowed)

Phase 2 – Member: Health History + Dashboard
1. Health History

Models (models/healthMetricModel.ts)

 addHealthMetric(memberId, metricType, value, unit?)

 getHealthMetrics(memberId, { from?, to? }) (ordered by recordedAt DESC)

Services (app/memberHealthService.ts)

 recordHealthMetric(memberId, metric) → validate input then call addHealthMetric

 getMemberHealthHistory(memberId) → wraps getHealthMetrics

2. Member Dashboard

Service (app/memberDashboardService.ts)
Implement a single function:

 getMemberDashboard(memberId) which:

Fetches basic Member info.

Gets latest health metrics (e.g., getHealthMetrics(memberId, limit=5)).

Gets upcoming PT sessions (Session where memberId and startTime > now).

Gets upcoming registered classes:

via ClassRegistration → FitnessClass where startTime > now.

This is just a combination of existing models. No new DB entities.

Phase 3 – PT Session Scheduling (Member + Trainer + Room + Availability)
1. Trainer Availability (recurring + one-time)

Models (models/trainerAvailabilityModel.ts)

 createOneTimeAvailability(trainerId, startDateTime, endDateTime)

 createWeeklyAvailability(trainerId, dayOfWeek, startTime, endTime)

 listTrainerAvailability(trainerId)

 deleteAvailability(id)

These will operate on your updated TrainerAvailability model (with type, ONE_TIME/WEEKLY, etc.).

Services (app/trainerAvailabilityService.ts)

 setOneTimeAvailability(trainerId, slot) → just calls createOneTimeAvailability

 setWeeklyAvailability(trainerId, slot) → calls createWeeklyAvailability

 getTrainerAvailability(trainerId) → for UI or tests

Trainer “Set availability” is done once these exist.

2. PT Sessions

Models (models/sessionModel.ts)

 createSession({ memberId, trainerId, roomId, startTime, endTime })

 listSessionsForMember(memberId, range?)

 listSessionsForTrainer(trainerId, range?)

3. Scheduling Logic Service

This is the important part that ties everything together.

Service (app/sessionSchedulingService.ts)

 isTrainerAvailable(trainerId, startTime, endTime)

Fetch TrainerAvailability for that trainer.

Check if requested interval fits into at least one ONE_TIME or WEEKLY availability.

 isRoomAvailable(roomId, startTime, endTime)

Check Session + FitnessClass for overlaps in that room.

 isMemberFree(memberId, startTime, endTime)

Check member’s Session + ClassRegistration/FitnessClass for overlaps.

 findAvailableRoom(startTime, endTime) (optional helper)

From Room, find one with no conflicts.

 schedulePtSession({ memberId, trainerId, requestedStart, requestedEnd })

Validate:

member exists

trainer exists

trainer available (isTrainerAvailable)

choose a room (findAvailableRoom)

member not busy / room not busy

If all good → call createSession.

Once this is done, you have PT session scheduling working.

Phase 4 – Group Class Registration
1. ClassRegistration

Models (models/classRegistrationModel.ts)

 registerMemberForClass(memberId, fitnessClassId)

 listRegistrationsForClass(fitnessClassId)

 listMemberClassRegistrations(memberId)

Service (app/classRegistrationService.ts)

 registerForClass(memberId, fitnessClassId):

Load FitnessClass (get start/end/capacity).

Count current registrations for that class.

If count ≥ capacity → throw “class full”.

Check for member schedule conflict:

existing Session + FitnessClass via ClassRegistration.

If okay → call registerMemberForClass.

This completes Group class registration for Members.

Phase 5 – Trainer Schedule View

Service (app/trainerScheduleService.ts)

 getTrainerSchedule(trainerId, range):

Fetch:

PT sessions (Session) for trainer in that range.

Fitness classes (FitnessClass) for trainer in that range.

Return a merged list, e.g.:

type ScheduleItem = {
  type: "PT_SESSION" | "CLASS";
  startTime: Date;
  endTime: Date;
  title: string;       // maybe member name or class name
  roomName: string;
};


Sort by startTime.

This gives Trainers a clean “schedule view”.

Phase 6 – Admin: Room Booking + Class Management
1. Room Booking

Room booking is basically enforced through your scheduling logic:

Rooms table already exists.

For PT sessions → schedulePtSession picks and validates room.

For classes → when admin creates/edits a FitnessClass, they choose a room and you validate conflicts.

Services (app/adminRoomService.ts)

 createRoom(name, capacity)

 listRooms()

 (optional) getRoomUsage(roomId, range) → read-only view of bookings.

2. Class Management

Services (app/adminClassService.ts)

 createClass({ name, trainerId, roomId, startTime, endTime, capacity })

Validate trainer exists.

Validate room exists.

Check:

room not booked (no Session/FitnessClass overlap).

trainer not busy with another class or PT session.

Call createFitnessClass.

 updateClass(id, data) → same validations on changes.

 cancelClass(id) → either delete or mark cancelled.

At this point, Admin can:

define rooms

define/cancel classes

effectively “book” rooms for classes.

Phase 7 – Glue / Testing Scripts

To actually see everything working, add a few small scripts:

Seed script (prisma/seed.ts or app/seed.ts)

 Create a few rooms.

 Create a couple of trainers, members, admin staff.

 Add some availability for trainers.

 Create one or two FitnessClass rows.

 Register a member for a class.

 Schedule a PT session.

Test scripts (in /app)

 testDashboard.ts → call getMemberDashboard(memberId) and console.log.

 testTrainerSchedule.ts → call getTrainerSchedule(trainerId, range) and log.

 testClassRegistration.ts → try registering member into a class and show success/failure.